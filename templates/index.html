<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Events Feed</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <link rel="stylesheet" href="/static/css/base.css">
  <style>
@keyframes marquee {
  0% { transform: translateX(100%); }
  100% { transform: translateX(-100%); }
}

.text-center a {
  color: #facc15;
  text-decoration: underline;
  font-weight: bold;
}
.message-strip-wrapper {
  position: relative;
  overflow: hidden;
  height: 2.25rem;
  background-color: #002855;
}

.message-strip {
  display: inline-block;
  white-space: nowrap;
  font-size: 1.2rem;
  font-weight: 600;
  color: white;
  animation: marquee 40s linear infinite; /* âœ… slower speed */
  will-change: transform;
  padding-left: 100%;
}

.message-strip a {
  color: #facc15; /* Bright yellow */
  text-decoration: underline;
  font-weight: bold;
  padding: 0 0.5rem;
}

.message-strip-wrapper:hover .message-strip {
  animation-play-state: paused;
  cursor: pointer;
}
</style>

</head>
<body class="bg-gray-100 text-gray-900 font-sans">
<div id="app">
  <!-- Header -->
 <header class="bg-brand-blue text-white px-4 py-3 shadow-md flex flex-wrap items-center justify-between gap-3 md:gap-6">

  <!-- Left Section: Logo & Title -->
  <div class="flex items-center gap-3 flex-shrink-0 w-full sm:w-auto justify-center sm:justify-start">
    <img v-if="tournamentLogo" :src="tournamentLogo" class="h-10 sm:h-12">
    <h1 class="text-lg sm:text-xl md:text-2xl font-bold text-center sm:text-left">
      {{ tournamentName || 'Big Rock Live' }}
    </h1>
  </div>

  <!-- Center Section: Buttons (wrap on small screens) -->
  <div class="flex flex-wrap justify-center gap-2 w-full sm:w-auto sm:flex-nowrap">
    <a href="/leaderboard"
       class="bg-brand-gold hover:bg-yellow-500 text-black font-bold px-3 py-1.5 sm:px-4 sm:py-2 rounded-lg shadow transition">
      Leaderboard
    </a>
    <a href="/participants"
       class="bg-brand-gold hover:bg-yellow-500 text-black font-bold px-3 py-1.5 sm:px-4 sm:py-2 rounded-lg shadow transition">
      Participants
    </a>
    <a href="/settings"
       class="bg-brand-gold hover:bg-yellow-500 text-black font-bold px-3 py-1.5 sm:px-4 sm:py-2 rounded-lg shadow transition">
      Settings
    </a>
    <button @click="toggleVhf"
       class="bg-green-600 hover:bg-green-700 text-white font-bold px-3 py-1.5 sm:px-4 sm:py-2 rounded-lg shadow transition">
      ðŸŽµ VHF
    </button>
  </div>

  <!-- Right Section: Version Text -->
  <div class="w-full sm:w-auto text-center sm:text-right text-xs text-white/70 mt-1 sm:mt-0">
    v{{ appVersion || '0.0.0' }}
  </div>
</header>




  <div class="flex h-screen overflow-hidden">
    <div class="w-1/3 bg-white border-r border-gray-300 overflow-y-auto">
      <div class="p-4 border-b text-xl font-bold bg-brand-blue text-white">Hooked Up</div>
      <div v-if="hooked.length === 0" class="p-4 text-gray-500 italic">No current hookups.</div>
      <div v-for="event in hooked" :key="event.timestamp + event.uid"
           :class="['p-4 border-b hover:bg-gray-50 flex items-center gap-4', isFollowed(event.uid) ? 'bg-yellow-100' : '']">
        <img :src="getBoatImage(event.uid)" class="w-20 h-20 object-cover rounded" onerror="this.style.display='none'" />
        <div>
          <div class="text-lg font-semibold">{{ event.boat }}</div>
          <div class="text-sm text-gray-600">Hooked Up at {{ formatTime(event.timestamp) }}</div>
        </div>
      </div>
    </div>

    <div class="w-2/3 overflow-y-auto">
      <div class="p-4 border-b text-xl font-bold flex justify-between items-center bg-brand-blue text-white">
        Event Feed
      </div>
      <div v-if="loading" class="p-4 text-gray-500 italic">Loading events...</div>
      <div v-else-if="events.length === 0" class="p-4 text-gray-500 italic">No events to show.</div>
      <div v-for="event in events" :key="event.timestamp + event.uid"
           :class="['p-4 border-b flex items-center gap-4 hover:bg-gray-50', isFollowed(event.uid) ? 'bg-yellow-100' : '']">
        <img :src="getBoatImage(event.uid)" class="w-20 h-20 object-cover rounded" onerror="this.style.display='none'" />
        <div>
          <div class="text-lg font-semibold">{{ event.boat }}</div>
          <div class="text-sm text-gray-600">{{ event.event }} â€” {{ formatTime(event.timestamp) }}</div>
          <div class="text-sm">{{ event.details }}</div>
        </div>
      </div>
    </div>
  </div>

  <audio id="radio-player" hidden></audio>
</div>

<script>
const { createApp } = Vue;

const app = createApp({
  data() {
    return {
      events: [],
      hooked: [],
      boatImages: {},
      tournamentLogo: '',
      version: '',
      loading: false,
      followed: JSON.parse(localStorage.getItem('followedBoats') || '[]'),
      lastEventTimestamps: new Set(),
      settings: {
        followed_sound: 'followed-activity',
        boated_sound: '1904_champagne-cork-pop-02',
        event_volume: 80,
        radio_volume: 30,
        sounds_enabled: true,
        data_source: 'live',
        tournament: ''
      },
      radioPlaying: false,
      hls: null,
      error: null,
      messageQueue: [],
      currentMessage: '',
      messageTimer: null,
      firstLoad: true   // âœ… Prevents sound spam on initial load
    };
  },

  mounted() {
    this.fetchSettings().then(() => {
      this.setupMessages();
      this.startMessageRotation();
      this.fetchVersion();
      this.loadTournamentLogo();
      this.loadParticipants();
      this.fetchAll();
      setInterval(this.fetchAll, 30000);
    });

    const player = document.getElementById('radio-player');
    if (player) player.volume = this.settings.radio_volume / 100;

    // Restore actual playback state
    const storedPlaying = localStorage.getItem('radioPlaying') === 'true';
    if (storedPlaying) {
      this.radioPlaying = !player.paused && !player.ended && player.currentTime > 0;
      if (!this.radioPlaying) {
        console.log('ðŸ”„ Auto-fix: forcing VHF to off because player is paused.');
        localStorage.setItem('radioPlaying', 'false');
      }
    } else {
      this.radioPlaying = false;
    }

    window.addEventListener('online', this.setupMessages);
    window.addEventListener('offline', this.setupMessages);
  },

  methods: {
    applyRadioVolume() {
      const player = document.getElementById('radio-player');
      if (player) {
        player.volume = this.settings.radio_volume / 100;
      }
    },

    toggleRadio() {
      const player = document.getElementById('radio-player');
      if (!player) return;

      if (this.radioPlaying) {
        if (this.hls) this.hls.destroy();
        player.pause();
        this.radioPlaying = false;
        localStorage.setItem('radioPlaying', 'false');
        return;
      }

      fetch('/api/settings')
        .then(res => res.json())
        .then(settings => {
          const tournament = settings.tournament;
          return fetch('https://js9467.github.io/Brtourney/settings.json')
            .then(res => res.json())
            .then(all => {
              const primary = all[tournament]?.stream;
              const fallback = all[tournament]?.fallback_stream || all.fallback_stream;

              const tryPlay = (url, label = 'Primary') => {
                return new Promise((resolve, reject) => {
                  if (!url) return reject(`${label} stream URL is missing.`);

                  if (Hls.isSupported()) {
                    if (this.hls) this.hls.destroy();
                    this.hls = new Hls();
                    this.hls.loadSource(url);
                    this.hls.attachMedia(player);
                    this.hls.on(Hls.Events.MANIFEST_PARSED, () => {
                      this.applyRadioVolume();
                      player.play().then(resolve).catch(reject);
                    });
                  } else if (player.canPlayType('application/vnd.apple.mpegurl')) {
                    player.src = url;
                    this.applyRadioVolume();
                    player.play().then(resolve).catch(reject);
                  } else {
                    reject(`${label} stream unsupported.`);
                  }

                  setTimeout(() => reject(`${label} stream timed out.`), 5000);
                });
              };

              tryPlay(primary, 'Primary')
                .then(() => {
                  this.radioPlaying = true;
                  this.error = null;
                  localStorage.setItem('radioPlaying', 'true');
                })
                .catch(primaryErr => {
                  console.warn("Primary stream failed:", primaryErr);
                  tryPlay(fallback, 'Fallback')
                    .then(() => {
                      this.radioPlaying = true;
                      this.error = "Your tournament VHF feed is currently unavailable. You are hearing sample audio.";
                      this.enqueueMessage(this.error);
                      localStorage.setItem('radioPlaying', 'true');
                    })
                    .catch(fallbackErr => {
                      console.error("Both streams failed:", fallbackErr);
                      this.radioPlaying = false;
                      this.error = "ðŸ”‡ Failed to play VHF stream.";
                      this.enqueueMessage(this.error);
                    });
                });
            });
        });
    },

    fetchSettings() {
      return fetch('/api/settings')
        .then(res => res.json())
        .then(data => {
          this.settings = { ...this.settings, ...data };
        });
    },

    fetchVersion() {
      fetch('/api/version')
        .then(res => res.json())
        .then(data => {
          this.version = data.version;
        });
    },

    setupMessages() {
      this.messageQueue = [];
      if (!navigator.onLine) {
        this.enqueueMessage(`ðŸ“¡ Offline. <a href='/settings-page'>Connect to WiFi</a> for live event updates.`);
      }
      if (this.settings.data_source === 'demo') {
        this.enqueueMessage(`You are in demo mode. Events are emulated from a previous tournament. <a href='#' onclick='injectTestEvent()'>To simulate a boated event, click here.</a>`);
      }
      if (this.radioPlaying && this.error) {
        this.enqueueMessage(this.error);
      }
    },

    enqueueMessage(msg) {
      if (!this.messageQueue.includes(msg)) this.messageQueue.push(msg);
    },

    startMessageRotation() {
      if (this.messageQueue.length === 0) return;

      let i = 0;
      this.currentMessage = this.messageQueue[i];

      if (this.messageTimer) clearInterval(this.messageTimer);

      this.messageTimer = setInterval(() => {
        i = (i + 1) % this.messageQueue.length;
        this.currentMessage = this.messageQueue[i];
      }, 7000);
    },

    fetchAll() {
      this.loading = true;
      Promise.all([
        fetch('/scrape/events').then(res => res.json()),
        fetch('/hooked').then(res => res.json())
      ])
        .then(([eventsData, hookedData]) => {
          const newEvents = eventsData.events || [];
          const newHooked = hookedData.events || [];

          // ðŸ”Š Play sounds for *new* events only, skip on first load
          for (const event of newEvents) {
            const key = event.timestamp + event.uid;
            const isNew = !this.lastEventTimestamps.has(key);

            this.lastEventTimestamps.add(key);

            if (isNew && !this.firstLoad && this.settings.sounds_enabled) {
              // âœ… Boated overrides followed
              if (event.event.toLowerCase().includes('boated')) {
                this.playSound(this.settings.boated_sound);
              } else if (this.isFollowed(event.uid)) {
                this.playSound(this.settings.followed_sound);
              }
            }
          }

          // âœ… After first fetch, disable firstLoad
          this.firstLoad = false;

          this.events = newEvents;
          this.hooked = newHooked;
          this.loading = false;
        })
        .catch(err => {
          console.error("âŒ Fetch error:", err);
          this.loading = false;
        });
    },

    getBoatImage(uid) {
      return this.boatImages[uid] || '';
    },

    loadParticipants() {
      fetch('/participants_data?limit=1000&offset=0')
        .then(res => res.json())
        .then(data => {
          const images = {};
          for (const p of data.participants) {
            images[p.uid] = p.image_path;
          }

          // Include Palmer Lou for demo
          images["palmer_lou"] = "/static/images/palmer_lou.jpg";

          this.boatImages = images;
        });
    },

    loadTournamentLogo() {
      fetch('/api/settings')
        .then(res => res.json())
        .then(settings => {
          const tournament = settings.tournament;
          return fetch('https://js9467.github.io/Brtourney/settings.json')
            .then(res => res.json())
            .then(all => {
              this.tournamentLogo = all[tournament]?.logo || '';
            });
        });
    },

    formatTime(ts) {
      const dt = new Date(ts);
      return dt.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
    },

    isFollowed(uid) {
      return this.followed.includes(uid);
    },

    playSound(filename) {
  if (!filename) return;

  // Remove any trailing .mp3 to avoid double extension
  const cleanName = filename.replace(/\.mp3$/i, '');

  const audio = new Audio(`/static/sounds/${cleanName}.mp3`);
  audio.volume = (this.settings.event_volume || 80) / 100;
  audio.play().catch(err => console.warn('ðŸ”‡ Sound failed:', err));
}

  }

}).mount('#app');

// Inject demo event for Palmer Lou
window.injectTestEvent = function () {
  const now = new Date();
  const future = new Date(now.getTime() + 10000).toISOString();
  const injected = {
    boat: "Palmer Lou",
    event: "Boated",
    details: "Palmer Lou has boated a massive Blue Marlin and will be heading to the scales.",
    timestamp: future,
    uid: "palmer_lou"
  };
  app.events.unshift(injected);
  app.lastEventTimestamps.add(injected.timestamp + injected.uid);
  app.playSound(app.settings.boated_sound);
};
</script>

</body>
</html>
