<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Events Feed</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <link rel="stylesheet" href="/static/css/base.css">
  <style>
    body { touch-action: manipulation; }
    .toast {
      position: fixed;
      top: 1rem;
      left: 50%;
      transform: translateX(-50%);
      background-color: #f59e0b;
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 0.375rem;
      z-index: 9999;
    }
  </style>
</head>
<body class="bg-gray-100 text-gray-900 font-sans">
  <div id="app">
    <div v-if="error" class="toast">{{ error }}</div>

    <header class="bg-brand-blue text-white px-4 py-3 shadow-md">
  <div class="flex items-center justify-between flex-wrap gap-4">
    
    <!-- Logo + VHF Status -->
    <div class="flex items-center gap-4">
      <img v-if="tournamentLogo" :src="tournamentLogo" alt="Tournament Logo" class="h-14 drop-shadow">
      <span v-else class="text-white text-base">Loading Logo...</span>
      <span v-if="radioPlaying" class="text-sm text-green-300 animate-pulse ml-2">🎧 VHF Playing</span>
    </div>

    <!-- Right side button group -->
    <div class="flex gap-4 items-start">
      <!-- VHF Button + Volume (stacked) -->
      <div class="flex flex-col items-center">
        <button @click="toggleRadio"
                class="px-4 py-2 w-36 text-white font-semibold border border-white rounded hover:bg-white hover:text-blue-900 transition">
          {{ radioPlaying ? 'VHF OFF' : 'VHF ON' }}
        </button>
        <div class="mt-1 flex items-center text-sm text-white gap-2 w-36 justify-center">
          <span class="text-lg">🔊</span>
          <input type="range" min="0" max="100" v-model="settings.radio_volume" @change="saveRadioVolume"
                 class="w-40 h-1 bg-white rounded-lg appearance-none cursor-pointer">
          <span class="w-8 text-right text-xs">{{ settings.radio_volume }}%</span>
        </div>
      </div>

      <!-- Other buttons -->
      <a href="/participants"
         class="px-3 py-2 w-36 text-center text-white font-semibold border border-white rounded hover:bg-white hover:text-blue-900 transition">
        Participants
      </a>
      <a href="/leaderboard"
         class="px-3 py-2 w-36 text-center text-white font-semibold border border-white rounded hover:bg-white hover:text-blue-900 transition">
        Leaderboard
      </a>
      <a href="/catch-summary"
         class="px-3 py-2 w-36 text-center text-white font-semibold border border-white rounded hover:bg-white hover:text-blue-900 transition">
        Catch Summary
      </a>
      <a href="/settings-page"
         class="w-12 h-12 flex items-center justify-center text-white text-xl border border-white rounded hover:bg-white hover:text-blue-900 transition">
        ⚙
      </a>
    </div>
  </div>
</header>




    <div class="flex h-screen overflow-hidden">
      <div class="w-1/3 bg-white border-r border-gray-300 overflow-y-auto">
        <div class="p-4 border-b text-xl font-bold bg-brand-blue text-white">Hooked Up</div>
        <div v-if="hooked.length === 0" class="p-4 text-gray-500 italic">No current hookups.</div>
        <div
          v-for="event in hooked"
          :key="event.timestamp + event.uid"
          :class="['p-4 border-b hover:bg-gray-50 flex items-center gap-4', isFollowed(event.uid) ? 'bg-yellow-100' : '']"
        >
          <img :src="getBoatImage(event.uid)" class="w-20 h-20 object-cover rounded" onerror="this.style.display='none'" />
          <div>
            <div class="text-lg font-semibold">{{ event.boat }}</div>
            <div class="text-sm text-gray-600">Hooked Up at {{ formatTime(event.timestamp) }}</div>
          </div>
        </div>
      </div>

      <div class="w-2/3 overflow-y-auto">
        <div class="p-4 border-b text-xl font-bold flex justify-between items-center bg-brand-blue text-white">
          Event Feed
        </div>

        <div v-if="loading" class="p-4 text-gray-500 italic">Loading events...</div>
        <div v-else-if="events.length === 0" class="p-4 text-gray-500 italic">No events to show.</div>

        <div
          v-for="event in events"
          :key="event.timestamp + event.uid"
          :class="['p-4 border-b flex items-center gap-4 hover:bg-gray-50', isFollowed(event.uid) ? 'bg-yellow-100' : '']"
        >
          <img :src="getBoatImage(event.uid)" class="w-20 h-20 object-cover rounded" onerror="this.style.display='none'" />
          <div>
            <div class="text-lg font-semibold">{{ event.boat }}</div>
            <div class="text-sm text-gray-600">{{ event.event }} — {{ formatTime(event.timestamp) }}</div>
            <div class="text-sm">{{ event.details }}</div>
          </div>
        </div>
      </div>
    </div>

    <audio id="radio-player" hidden></audio>
  </div>

  <script>
const { createApp } = Vue

createApp({
  data() {
    return {
      events: [],
      hooked: [],
      boatImages: {},
      tournamentLogo: '',
      loading: false,
      followed: JSON.parse(localStorage.getItem('followedBoats') || '[]'),
      lastEventTimestamps: new Set(),
      settings: {
        followed_sound: 'followed-activity',
        boated_sound: 'hooked-up',
        event_volume: 80,
        radio_volume: 30,
        sounds_enabled: true
      },
      radioPlaying: false,
      hls: null,
      error: null
    }
  },

  mounted() {
    this.loadParticipants();
    this.loadTournamentLogo();
    this.fetchSettings().then(() => {
      this.settings.radio_volume = parseInt(localStorage.getItem('radio_volume')) || 30;
      this.fetchAll();
      setInterval(this.fetchAll, 30000);
    });
    this.radioPlaying = localStorage.getItem('radioPlaying') === 'true';
    const player = document.getElementById('radio-player');
    if (player) {
      player.volume = this.settings.radio_volume / 100;
    }
  },

  methods: {
    toggleRadio() {
  const player = document.getElementById('radio-player');
  const tournamentName = this.settings.tournament;

  fetch('https://js9467.github.io/Brtourney/settings.json')
    .then(res => res.json())
    .then(all => {
      const tourney = all[tournamentName] || {};
      const streamUrl = tourney.stream || '';
      const fallbackStream = all.fallback_stream || '';

      const fallbackMessageBase = '🎣 Tournament VHF currently unavailable. Using fallback stream.';
      const isDemo = this.settings.data_source === 'demo';
      const fallbackMessage = isDemo ? `${fallbackMessageBase} You are in demo mode.` : fallbackMessageBase;

      const play = (url, isFallback = false) => {
        if (Hls.isSupported()) {
          if (this.hls) this.hls.destroy();
          this.hls = new Hls();
          this.hls.loadSource(url);
          this.hls.attachMedia(player);

          this.hls.on(Hls.Events.MANIFEST_PARSED, () => {
            player.volume = this.settings.radio_volume / 100;
            player.play().then(() => {
              this.radioPlaying = true;
              this.error = isFallback ? fallbackMessage : null;
              localStorage.setItem('radioPlaying', 'true');
            }).catch(err => {
              console.error('🔊 Audio play failed:', err);
              if (!isFallback) {
                this.hls.destroy();
                this.hls = null;
                play(fallbackStream, true);
              } else {
                this.error = fallbackMessage;
                this.radioPlaying = false;
              }
            });
          });

          this.hls.on(Hls.Events.ERROR, (event, data) => {
            if (data.fatal) {
              this.hls.destroy();
              this.hls = null;
              if (!isFallback) {
                play(fallbackStream, true);
              } else {
                this.error = fallbackMessage;
                this.radioPlaying = false;
              }
            }
          });

        } else if (player.canPlayType('application/vnd.apple.mpegurl')) {
          player.src = url;
          player.volume = this.settings.radio_volume / 100;
          player.play().then(() => {
            this.radioPlaying = true;
            this.error = isFallback ? fallbackMessage : null;
            localStorage.setItem('radioPlaying', 'true');
          }).catch(err => {
            if (!isFallback) {
              play(fallbackStream, true);
            } else {
              this.error = fallbackMessage;
              this.radioPlaying = false;
            }
          });
        } else {
          this.error = fallbackMessage;
          this.radioPlaying = false;
        }
      };

      if (this.radioPlaying) {
        if (this.hls) this.hls.destroy();
        player.pause();
        player.src = '';
        this.radioPlaying = false;
        this.error = null;
        localStorage.setItem('radioPlaying', 'false');
      } else {
        player.src = '';
        play(streamUrl || fallbackStream, false);
      }
    })
    .catch(err => {
      console.error("⚠️ Error fetching stream settings:", err);
      this.error = 'Unable to load VHF stream settings.';
    });
},


    saveRadioVolume() {
      localStorage.setItem('radio_volume', this.settings.radio_volume);
      const player = document.getElementById('radio-player');
      if (player) {
        player.volume = this.settings.radio_volume / 100;
      }
    },

    fetchSettings() {
      return fetch('/api/settings')
        .then(res => res.json())
        .then(data => {
          this.settings = { ...this.settings, ...data }
        });
    },

    fetchAll() {
      this.loading = true;
      Promise.all([
        fetch('/scrape/events').then(res => res.json()),
        fetch('/hooked').then(res => res.json())
      ]).then(([eventsData, hookedData]) => {
        const newEvents = eventsData.events || [];
        const newHooked = hookedData.events || [];
        this.handleNewEvents(newEvents);
        this.events = newEvents;
        this.hooked = newHooked;
        this.loading = false;
      }).catch(err => {
        console.error("❌ Fetch error:", err);
        this.loading = false;
      });
    },

    handleNewEvents(events) {
      for (const event of events) {
        const key = event.timestamp + event.uid;
        if (!this.lastEventTimestamps.has(key)) {
          this.lastEventTimestamps.add(key);
          if (this.settings.sounds_enabled) {
            const isFollowed = this.isFollowed(event.uid);
            const isBoated = event.details.toLowerCase().includes('boated');
            if (isBoated) this.playSound(this.settings.boated_sound);
            else if (isFollowed) this.playSound(this.settings.followed_sound);
          }
        }
      }
    },

    playSound(name) {
      const audio = new Audio(`/static/sounds/${name}.mp3`);
      audio.volume = this.settings.event_volume / 100;
      audio.play().catch(e => console.warn("🔇 Sound failed to play:", e));
    },

    loadParticipants() {
      fetch('/participants_data?limit=1000&offset=0')
        .then(res => res.json())
        .then(data => {
          const images = {};
          for (const p of data.participants) {
            images[p.uid] = p.image_path;
          }
          this.boatImages = images;
        });
    },

    getBoatImage(uid) {
      return this.boatImages[uid] || '';
    },

    formatTime(ts) {
      try {
        const dt = new Date(ts);
        return dt.toLocaleTimeString('en-US', {
          hour: 'numeric',
          minute: '2-digit',
          hour12: true
        });
      } catch {
        return ts;
      }
    },

    isFollowed(uid) {
      return this.followed.includes(uid);
    },

    loadTournamentLogo() {
      fetch('/api/settings')
        .then(res => res.json())
        .then(settings => {
          const tournament = settings.tournament;
          return fetch('https://js9467.github.io/Brtourney/settings.json')
            .then(res => res.json())
            .then(all => {
              this.tournamentLogo = all[tournament]?.logo || '';
            });
        });
    }
  }
}).mount('#app');
</script>

</body>
</html>
